1 @@ testCode/CVE-2013-0852_CWE-119_c0d68be555f5858703383040e04fcd6529777061_pgssubdec.c_1.1_OLD.c @@ parse_picture_segment @@ 225 @@ ['buf_size'] @@ {avctx, buf}
static int parse_picture_segment(AVCodecContext *avctx,
const uint8_t *buf, int buf_size) location: 176 cross_layer: 1 file: pgssubdec.c
uint8_t sequence_desc ; location: 180 cross_layer: 1 file: pgssubdec.c
unsigned int rle_bitmap_len , width , height ; location: 181 cross_layer: 1 file: pgssubdec.c
if ( buf_size <= 4 )  location: 184 cross_layer: 1 file: pgssubdec.c
buf_size -= 4; location: 186 cross_layer: 1 file: pgssubdec.c
buf ++; location: 191 cross_layer: 1 file: pgssubdec.c
sequence_desc = bytestream_get_byte ( & buf ); location: 194 cross_layer: 1 file: pgssubdec.c
if ( ! ( sequence_desc & 0x80 ) )  location: 196 cross_layer: 1 file: pgssubdec.c
if ( buf_size <= 7 )  location: 208 cross_layer: 1 file: pgssubdec.c
buf_size -= 7; location: 210 cross_layer: 1 file: pgssubdec.c
rle_bitmap_len = bytestream_get_be24 ( & buf ) - 2 * 2; location: 213 cross_layer: 1 file: pgssubdec.c
width = bytestream_get_be16 ( & buf ); location: 216 cross_layer: 1 file: pgssubdec.c
height = bytestream_get_be16 ( & buf ); location: 217 cross_layer: 1 file: pgssubdec.c
if ( avctx -> width < width || avctx -> height < height )  location: 220 cross_layer: 1 file: pgssubdec.c
ctx -> pictures [ picture_id ] . w = width; location: 225 cross_layer: 1 file: pgssubdec.c    (key_var lines)
ctx -> pictures [ picture_id ] . h = height; location: 226 cross_layer: 1 file: pgssubdec.c
av_fast_malloc ( & ctx -> pictures [ picture_id ] . rle , & ctx -> pictures [ picture_id ] . rle_buffer_size , rle_bitmap_len ); location: 228 cross_layer: 1 file: pgssubdec.c
if ( ! ctx -> pictures [ picture_id ] . rle )  location: 230 cross_layer: 1 file: pgssubdec.c
memcpy ( ctx -> pictures [ picture_id ] . rle , buf , buf_size ); location: 233 cross_layer: 1 file: pgssubdec.c
ctx -> pictures [ picture_id ] . rle_data_len = buf_size; location: 234 cross_layer: 1 file: pgssubdec.c
ctx -> pictures [ picture_id ] . rle_remaining_len = rle_bitmap_len - buf_size; location: 235 cross_layer: 1 file: pgssubdec.c
parse_picture_segment ( avctx , buf , segment_length ); location: 488 cross_layer: 2 file: pgssubdec.c
parse_presentation_segment ( avctx , buf , segment_length ); location: 491 cross_layer: 2 file: pgssubdec.c
static void parse_presentation_segment(AVCodecContext *avctx,
const uint8_t *buf, int buf_size) location: 293 cross_layer: 3 file: pgssubdec.c
PGSSubContext * ctx = avctx -> priv_data ; location: 295 cross_layer: 3 file: pgssubdec.c
int w = bytestream_get_be16 ( & buf ) ; location: 297 cross_layer: 3 file: pgssubdec.c
int h = bytestream_get_be16 ( & buf ) ; location: 298 cross_layer: 3 file: pgssubdec.c
av_dlog ( avctx , "Video Dimensions %dx%d\n" , w , h ); location: 302 cross_layer: 3 file: pgssubdec.c
if ( av_image_check_size ( w , h , 0 , avctx ) >= 0 )  location: 304 cross_layer: 3 file: pgssubdec.c
avcodec_set_dimensions ( avctx , w , h ); location: 305 cross_layer: 3 file: pgssubdec.c
buf ++; location: 308 cross_layer: 3 file: pgssubdec.c
ctx -> presentation . id_number = bytestream_get_be16 ( & buf ); location: 310 cross_layer: 3 file: pgssubdec.c
buf += 3; location: 318 cross_layer: 3 file: pgssubdec.c
ctx -> presentation . object_count = bytestream_get_byte ( & buf ); location: 320 cross_layer: 3 file: pgssubdec.c
if ( ! ctx -> presentation . object_count )  location: 321 cross_layer: 3 file: pgssubdec.c
buf_size -= 11; location: 325 cross_layer: 3 file: pgssubdec.c
if ( buf_size < ctx -> presentation . object_count * 8 )  location: 326 cross_layer: 3 file: pgssubdec.c
ctx -> presentation . object_count = 0; location: 327 cross_layer: 3 file: pgssubdec.c
av_freep ( & ctx -> presentation . objects ); location: 331 cross_layer: 3 file: pgssubdec.c
ctx -> presentation . objects = av_malloc ( sizeof ( PGSSubPictureReference ) * ctx -> presentation . object_count ); location: 332 cross_layer: 3 file: pgssubdec.c
if ( ! ctx -> presentation . objects )  location: 333 cross_layer: 3 file: pgssubdec.c
ctx -> presentation . object_count = 0; location: 334 cross_layer: 3 file: pgssubdec.c
for (object_index = 0; object_index < ctx->presentation.object_count; ++object_index) location: 338 cross_layer: 3 file: pgssubdec.c
PGSSubPictureReference * reference = & ctx -> presentation . objects [ object_index ] ; location: 339 cross_layer: 3 file: pgssubdec.c
reference -> picture_id = bytestream_get_be16 ( & buf ); location: 340 cross_layer: 3 file: pgssubdec.c
buf ++; location: 343 cross_layer: 3 file: pgssubdec.c
reference -> composition = bytestream_get_byte ( & buf ); location: 345 cross_layer: 3 file: pgssubdec.c
reference -> x = bytestream_get_be16 ( & buf ); location: 347 cross_layer: 3 file: pgssubdec.c
reference -> y = bytestream_get_be16 ( & buf ); location: 348 cross_layer: 3 file: pgssubdec.c
av_dlog ( avctx , "Subtitle Placement ID=%d, x=%d, y=%d\n" , reference -> picture_id , reference -> x , reference -> y ); location: 351 cross_layer: 3 file: pgssubdec.c
if ( reference -> x > avctx -> width || reference -> y > avctx -> height )  location: 353 cross_layer: 3 file: pgssubdec.c
av_log ( avctx , AV_LOG_ERROR , "Subtitle out of video bounds. x = %d, y = %d, video width = %d, video height = %d.\n" , reference -> x , reference -> y , avctx -> width , avctx -> height ); location: 354 cross_layer: 3 file: pgssubdec.c
reference -> x = 0; location: 356 cross_layer: 3 file: pgssubdec.c
reference -> y = 0; location: 357 cross_layer: 3 file: pgssubdec.c
ctx -> pts = sub -> pts; location: 492 cross_layer: 2 file: pgssubdec.c
* data_size = display_end_segment ( avctx , data , buf , segment_length ); location: 505 cross_layer: 2 file: pgssubdec.c
static int display_end_segment(AVCodecContext *avctx, void *data,
const uint8_t *buf, int buf_size) location: 378 cross_layer: 3 file: pgssubdec.c
AVSubtitle * sub = data ; location: 380 cross_layer: 3 file: pgssubdec.c
PGSSubContext * ctx = avctx -> priv_data ; location: 381 cross_layer: 3 file: pgssubdec.c
pts = ctx -> pts != AV_NOPTS_VALUE ? ctx -> pts : sub -> pts; location: 392 cross_layer: 3 file: pgssubdec.c
memset ( sub , 0 , sizeof ( * sub ) ); location: 393 cross_layer: 3 file: pgssubdec.c
sub -> pts = pts; location: 394 cross_layer: 3 file: pgssubdec.c
ctx -> pts = AV_NOPTS_VALUE; location: 395 cross_layer: 3 file: pgssubdec.c
if ( ! ctx -> presentation . object_count )  location: 398 cross_layer: 3 file: pgssubdec.c
sub -> start_display_time = 0; location: 401 cross_layer: 3 file: pgssubdec.c
sub -> end_display_time = 20000; location: 402 cross_layer: 3 file: pgssubdec.c
sub -> format = 0; location: 403 cross_layer: 3 file: pgssubdec.c
sub -> num_rects = ctx -> presentation . object_count; location: 405 cross_layer: 3 file: pgssubdec.c
sub -> rects = av_mallocz ( sizeof ( * sub -> rects ) * sub -> num_rects ); location: 406 cross_layer: 3 file: pgssubdec.c
for (rect = 0; rect < sub->num_rects; ++rect) location: 408 cross_layer: 3 file: pgssubdec.c
uint16_t picture_id = ctx -> presentation . objects [ rect ] . picture_id ; location: 409 cross_layer: 3 file: pgssubdec.c
sub -> rects [ rect ] = av_mallocz ( sizeof ( * sub -> rects [ rect ] ) ); location: 410 cross_layer: 3 file: pgssubdec.c
sub -> rects [ rect ] -> x = ctx -> presentation . objects [ rect ] . x; location: 411 cross_layer: 3 file: pgssubdec.c
sub -> rects [ rect ] -> y = ctx -> presentation . objects [ rect ] . y; location: 412 cross_layer: 3 file: pgssubdec.c
sub -> rects [ rect ] -> w = ctx -> pictures [ picture_id ] . w; location: 413 cross_layer: 3 file: pgssubdec.c
sub -> rects [ rect ] -> h = ctx -> pictures [ picture_id ] . h; location: 414 cross_layer: 3 file: pgssubdec.c
sub -> rects [ rect ] -> type = SUBTITLE_BITMAP; location: 415 cross_layer: 3 file: pgssubdec.c
sub -> rects [ rect ] -> pict . linesize [ 0 ] = ctx -> pictures [ picture_id ] . w; location: 418 cross_layer: 3 file: pgssubdec.c
if ( ctx -> pictures [ picture_id ] . rle )  location: 419 cross_layer: 3 file: pgssubdec.c
if ( ctx -> pictures [ picture_id ] . rle_remaining_len )  location: 420 cross_layer: 3 file: pgssubdec.c
av_log ( avctx , AV_LOG_ERROR , "RLE data length %u is %u bytes shorter than expected\n" , ctx -> pictures [ picture_id ] . rle_data_len , ctx -> pictures [ picture_id ] . rle_remaining_len ); location: 421 cross_layer: 3 file: pgssubdec.c
if ( decode_rle ( avctx , sub , rect , ctx -> pictures [ picture_id ] . rle , ctx -> pictures [ picture_id ] . rle_data_len ) < 0 )  location: 423 cross_layer: 3 file: pgssubdec.c
sub -> rects [ rect ] -> nb_colors = 256; location: 428 cross_layer: 3 file: pgssubdec.c
sub -> rects [ rect ] -> pict . data [ 1 ] = av_mallocz ( AVPALETTE_SIZE ); location: 429 cross_layer: 3 file: pgssubdec.c
sub -> rects [ rect ] -> flags = ( ctx -> presentation . objects [ rect ] . composition & 0x40 ) != 0 ? AV_SUBTITLE_FLAG_FORCED : 0; location: 432 cross_layer: 3 file: pgssubdec.c
if ( ! ctx -> forced_subs_only || ctx -> presentation . objects [ rect ] . composition & 0x40 )  location: 434 cross_layer: 3 file: pgssubdec.c
memcpy ( sub -> rects [ rect ] -> pict . data [ 1 ] , ctx -> clut , sub -> rects [ rect ] -> nb_colors * sizeof ( uint32_t ) ); location: 435 cross_layer: 3 file: pgssubdec.c
av_log ( avctx , AV_LOG_ERROR , "Unknown subtitle segment type 0x%x, length %d\n" , segment_type , segment_length ); location: 508 cross_layer: 2 file: pgssubdec.c
buf += segment_length; location: 513 cross_layer: 2 file: pgssubdec.c
------------------------------
2 @@ testCode/CVE-2013-0852_CWE-119_c0d68be555f5858703383040e04fcd6529777061_pgssubdec.c_1.1_OLD.c @@ parse_picture_segment @@ 226 @@ ['avctx'] @@ {avctx, buf}
static int parse_picture_segment(AVCodecContext *avctx,
const uint8_t *buf, int buf_size) location: 176 cross_layer: 1 file: pgssubdec.c
uint8_t sequence_desc ; location: 180 cross_layer: 1 file: pgssubdec.c
unsigned int rle_bitmap_len , width , height ; location: 181 cross_layer: 1 file: pgssubdec.c
if ( buf_size <= 4 )  location: 184 cross_layer: 1 file: pgssubdec.c
buf_size -= 4; location: 186 cross_layer: 1 file: pgssubdec.c
buf ++; location: 191 cross_layer: 1 file: pgssubdec.c
sequence_desc = bytestream_get_byte ( & buf ); location: 194 cross_layer: 1 file: pgssubdec.c
if ( ! ( sequence_desc & 0x80 ) )  location: 196 cross_layer: 1 file: pgssubdec.c
if ( buf_size <= 7 )  location: 208 cross_layer: 1 file: pgssubdec.c
buf_size -= 7; location: 210 cross_layer: 1 file: pgssubdec.c
rle_bitmap_len = bytestream_get_be24 ( & buf ) - 2 * 2; location: 213 cross_layer: 1 file: pgssubdec.c
width = bytestream_get_be16 ( & buf ); location: 216 cross_layer: 1 file: pgssubdec.c
height = bytestream_get_be16 ( & buf ); location: 217 cross_layer: 1 file: pgssubdec.c
if ( avctx -> width < width || avctx -> height < height )  location: 220 cross_layer: 1 file: pgssubdec.c
ctx -> pictures [ picture_id ] . w = width; location: 225 cross_layer: 1 file: pgssubdec.c    (key_var lines)
ctx -> pictures [ picture_id ] . h = height; location: 226 cross_layer: 1 file: pgssubdec.c
av_fast_malloc ( & ctx -> pictures [ picture_id ] . rle , & ctx -> pictures [ picture_id ] . rle_buffer_size , rle_bitmap_len ); location: 228 cross_layer: 1 file: pgssubdec.c
if ( ! ctx -> pictures [ picture_id ] . rle )  location: 230 cross_layer: 1 file: pgssubdec.c
memcpy ( ctx -> pictures [ picture_id ] . rle , buf , buf_size ); location: 233 cross_layer: 1 file: pgssubdec.c
ctx -> pictures [ picture_id ] . rle_data_len = buf_size; location: 234 cross_layer: 1 file: pgssubdec.c
ctx -> pictures [ picture_id ] . rle_remaining_len = rle_bitmap_len - buf_size; location: 235 cross_layer: 1 file: pgssubdec.c
parse_picture_segment ( avctx , buf , segment_length ); location: 488 cross_layer: 2 file: pgssubdec.c
parse_presentation_segment ( avctx , buf , segment_length ); location: 491 cross_layer: 2 file: pgssubdec.c
static void parse_presentation_segment(AVCodecContext *avctx,
const uint8_t *buf, int buf_size) location: 293 cross_layer: 3 file: pgssubdec.c
PGSSubContext * ctx = avctx -> priv_data ; location: 295 cross_layer: 3 file: pgssubdec.c
int w = bytestream_get_be16 ( & buf ) ; location: 297 cross_layer: 3 file: pgssubdec.c
int h = bytestream_get_be16 ( & buf ) ; location: 298 cross_layer: 3 file: pgssubdec.c
av_dlog ( avctx , "Video Dimensions %dx%d\n" , w , h ); location: 302 cross_layer: 3 file: pgssubdec.c
if ( av_image_check_size ( w , h , 0 , avctx ) >= 0 )  location: 304 cross_layer: 3 file: pgssubdec.c
avcodec_set_dimensions ( avctx , w , h ); location: 305 cross_layer: 3 file: pgssubdec.c
buf ++; location: 308 cross_layer: 3 file: pgssubdec.c
ctx -> presentation . id_number = bytestream_get_be16 ( & buf ); location: 310 cross_layer: 3 file: pgssubdec.c
buf += 3; location: 318 cross_layer: 3 file: pgssubdec.c
ctx -> presentation . object_count = bytestream_get_byte ( & buf ); location: 320 cross_layer: 3 file: pgssubdec.c
if ( ! ctx -> presentation . object_count )  location: 321 cross_layer: 3 file: pgssubdec.c
buf_size -= 11; location: 325 cross_layer: 3 file: pgssubdec.c
if ( buf_size < ctx -> presentation . object_count * 8 )  location: 326 cross_layer: 3 file: pgssubdec.c
ctx -> presentation . object_count = 0; location: 327 cross_layer: 3 file: pgssubdec.c
av_freep ( & ctx -> presentation . objects ); location: 331 cross_layer: 3 file: pgssubdec.c
ctx -> presentation . objects = av_malloc ( sizeof ( PGSSubPictureReference ) * ctx -> presentation . object_count ); location: 332 cross_layer: 3 file: pgssubdec.c
if ( ! ctx -> presentation . objects )  location: 333 cross_layer: 3 file: pgssubdec.c
ctx -> presentation . object_count = 0; location: 334 cross_layer: 3 file: pgssubdec.c
for (object_index = 0; object_index < ctx->presentation.object_count; ++object_index) location: 338 cross_layer: 3 file: pgssubdec.c
PGSSubPictureReference * reference = & ctx -> presentation . objects [ object_index ] ; location: 339 cross_layer: 3 file: pgssubdec.c
reference -> picture_id = bytestream_get_be16 ( & buf ); location: 340 cross_layer: 3 file: pgssubdec.c
buf ++; location: 343 cross_layer: 3 file: pgssubdec.c
reference -> composition = bytestream_get_byte ( & buf ); location: 345 cross_layer: 3 file: pgssubdec.c
reference -> x = bytestream_get_be16 ( & buf ); location: 347 cross_layer: 3 file: pgssubdec.c
reference -> y = bytestream_get_be16 ( & buf ); location: 348 cross_layer: 3 file: pgssubdec.c
av_dlog ( avctx , "Subtitle Placement ID=%d, x=%d, y=%d\n" , reference -> picture_id , reference -> x , reference -> y ); location: 351 cross_layer: 3 file: pgssubdec.c
if ( reference -> x > avctx -> width || reference -> y > avctx -> height )  location: 353 cross_layer: 3 file: pgssubdec.c
av_log ( avctx , AV_LOG_ERROR , "Subtitle out of video bounds. x = %d, y = %d, video width = %d, video height = %d.\n" , reference -> x , reference -> y , avctx -> width , avctx -> height ); location: 354 cross_layer: 3 file: pgssubdec.c
reference -> x = 0; location: 356 cross_layer: 3 file: pgssubdec.c
reference -> y = 0; location: 357 cross_layer: 3 file: pgssubdec.c
ctx -> pts = sub -> pts; location: 492 cross_layer: 2 file: pgssubdec.c
* data_size = display_end_segment ( avctx , data , buf , segment_length ); location: 505 cross_layer: 2 file: pgssubdec.c
static int display_end_segment(AVCodecContext *avctx, void *data,
const uint8_t *buf, int buf_size) location: 378 cross_layer: 3 file: pgssubdec.c
AVSubtitle * sub = data ; location: 380 cross_layer: 3 file: pgssubdec.c
PGSSubContext * ctx = avctx -> priv_data ; location: 381 cross_layer: 3 file: pgssubdec.c
pts = ctx -> pts != AV_NOPTS_VALUE ? ctx -> pts : sub -> pts; location: 392 cross_layer: 3 file: pgssubdec.c
memset ( sub , 0 , sizeof ( * sub ) ); location: 393 cross_layer: 3 file: pgssubdec.c
sub -> pts = pts; location: 394 cross_layer: 3 file: pgssubdec.c
ctx -> pts = AV_NOPTS_VALUE; location: 395 cross_layer: 3 file: pgssubdec.c
if ( ! ctx -> presentation . object_count )  location: 398 cross_layer: 3 file: pgssubdec.c
sub -> start_display_time = 0; location: 401 cross_layer: 3 file: pgssubdec.c
sub -> end_display_time = 20000; location: 402 cross_layer: 3 file: pgssubdec.c
sub -> format = 0; location: 403 cross_layer: 3 file: pgssubdec.c
sub -> num_rects = ctx -> presentation . object_count; location: 405 cross_layer: 3 file: pgssubdec.c
sub -> rects = av_mallocz ( sizeof ( * sub -> rects ) * sub -> num_rects ); location: 406 cross_layer: 3 file: pgssubdec.c
for (rect = 0; rect < sub->num_rects; ++rect) location: 408 cross_layer: 3 file: pgssubdec.c
uint16_t picture_id = ctx -> presentation . objects [ rect ] . picture_id ; location: 409 cross_layer: 3 file: pgssubdec.c
sub -> rects [ rect ] = av_mallocz ( sizeof ( * sub -> rects [ rect ] ) ); location: 410 cross_layer: 3 file: pgssubdec.c
sub -> rects [ rect ] -> x = ctx -> presentation . objects [ rect ] . x; location: 411 cross_layer: 3 file: pgssubdec.c
sub -> rects [ rect ] -> y = ctx -> presentation . objects [ rect ] . y; location: 412 cross_layer: 3 file: pgssubdec.c
sub -> rects [ rect ] -> w = ctx -> pictures [ picture_id ] . w; location: 413 cross_layer: 3 file: pgssubdec.c
sub -> rects [ rect ] -> h = ctx -> pictures [ picture_id ] . h; location: 414 cross_layer: 3 file: pgssubdec.c
sub -> rects [ rect ] -> type = SUBTITLE_BITMAP; location: 415 cross_layer: 3 file: pgssubdec.c
sub -> rects [ rect ] -> pict . linesize [ 0 ] = ctx -> pictures [ picture_id ] . w; location: 418 cross_layer: 3 file: pgssubdec.c
if ( ctx -> pictures [ picture_id ] . rle )  location: 419 cross_layer: 3 file: pgssubdec.c
if ( ctx -> pictures [ picture_id ] . rle_remaining_len )  location: 420 cross_layer: 3 file: pgssubdec.c
av_log ( avctx , AV_LOG_ERROR , "RLE data length %u is %u bytes shorter than expected\n" , ctx -> pictures [ picture_id ] . rle_data_len , ctx -> pictures [ picture_id ] . rle_remaining_len ); location: 421 cross_layer: 3 file: pgssubdec.c
if ( decode_rle ( avctx , sub , rect , ctx -> pictures [ picture_id ] . rle , ctx -> pictures [ picture_id ] . rle_data_len ) < 0 )  location: 423 cross_layer: 3 file: pgssubdec.c
sub -> rects [ rect ] -> nb_colors = 256; location: 428 cross_layer: 3 file: pgssubdec.c
sub -> rects [ rect ] -> pict . data [ 1 ] = av_mallocz ( AVPALETTE_SIZE ); location: 429 cross_layer: 3 file: pgssubdec.c
sub -> rects [ rect ] -> flags = ( ctx -> presentation . objects [ rect ] . composition & 0x40 ) != 0 ? AV_SUBTITLE_FLAG_FORCED : 0; location: 432 cross_layer: 3 file: pgssubdec.c
if ( ! ctx -> forced_subs_only || ctx -> presentation . objects [ rect ] . composition & 0x40 )  location: 434 cross_layer: 3 file: pgssubdec.c
memcpy ( sub -> rects [ rect ] -> pict . data [ 1 ] , ctx -> clut , sub -> rects [ rect ] -> nb_colors * sizeof ( uint32_t ) ); location: 435 cross_layer: 3 file: pgssubdec.c
av_log ( avctx , AV_LOG_ERROR , "Unknown subtitle segment type 0x%x, length %d\n" , segment_type , segment_length ); location: 508 cross_layer: 2 file: pgssubdec.c
buf += segment_length; location: 513 cross_layer: 2 file: pgssubdec.c
------------------------------
